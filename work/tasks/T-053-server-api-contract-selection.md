# T-053: Server API for contract selection using Action Provider

- Type: Task
- Status: Todo
- Feature: F-016
- Source: R-006
- Architecture: A-013 (Rule-Based Engine and Action Provider)
- Depends on: T-051, T-052

## Goal

Extend the server's unified action endpoint to support Contract Selection phase actions, exposing `possibleActions` in game state responses and enabling clients to submit contract-related actions through the Action Provider pattern.

## Scope

**IN:**
- Extend unified `/games/{gameId}/actions` endpoint to handle contract action types
- Action deserialization for all contract action types (AnnounceContract, DoubleCommitment, etc.)
- Display name generation for contract actions in `possibleActions`
- GameState response includes `ContractSelectionMetadata` in JSON
- Error handling for validation failures from `RuleSet.validate()`
- Action submission flow: deserialize → authenticate → validate → reduce → persist → respond
- OpenAPI schema updates for contract metadata and actions
- API documentation updates in `docs/API.md`
- Test cases in `docs/api-tests.http`

**OUT:**
- Engine logic (covered in T-051)
- Metadata structures (covered in T-052)
- UI implementation (covered in T-054)
- Real-time event emission (depends on F-011 if available)

## Objective

Implement REST API endpoints that leverage the Action Provider pattern from A-013. The server exposes `possibleActions` in game state responses and accepts generic action submissions, eliminating the need for phase-specific endpoints.

## Requirements

### 1. Unified Action Endpoint

Per A-013, use a **single unified endpoint** for all player actions instead of phase-specific endpoints:

#### Submit Action
```
POST /games/{gameId}/actions
Body: {
  "actionType": "AnnounceContract" | "AcceptContracts" | "DoubleCommitment" | "AnnounceDefenseContract" | "DeclareOpenHand" | "RespondToOpenHand",
  "payload": {
    // Action-specific fields
    // e.g., for AnnounceContract: { "contract": "HUNDRED" }
    // e.g., for DoubleCommitment: { "commitmentId": "abc123" }
  }
}
Response: {
  "success": true,
  "gameState": GameState  // includes possibleActions
}
```

**Note:** This endpoint is already generic. This task extends it to handle contract selection action types.

### 2. GameState Response Structure

Ensure `GET /games/{gameId}` and action responses include:

```json
{
  "gameId": "...",
  "phase": "CONTRACT_SELECTION",
  "cardMap": { /* Map<Card, CardPosition> */ },
  "metadata": {
    "type": "ContractSelectionMetadata",
    "declarerCommitment": { /* Commitment */ },
    "defenseCommitments": [ /* List<Commitment> */ ],
    "currentRespondingPlayerId": "player2",
    "playersResponded": ["player1"],
    "openHandState": null,
    "phaseComplete": false
  },
  "possibleActions": [
    {
      "actionType": "AcceptContracts",
      "playerId": "player2",
      "displayName": "Good",
      "payload": {}
    },
    {
      "actionType": "DoubleCommitment",
      "playerId": "player2",
      "displayName": "Double declarer's Game (2x → 4x)",
      "payload": { "commitmentId": "decl-game-1" }
    },
    {
      "actionType": "AnnounceDefenseContract",
      "playerId": "player2",
      "displayName": "Announce Hundred",
      "payload": { "contract": "HUNDRED" }
    }
  ],
  "history": [ /* List<GameAction> */ ]
}
```

**Key A-013 principles:**
- `possibleActions` generated by `RuleSet.possibleActions(state, playerId)`
- Actions include `displayName` for UI rendering
- Client submits action from `possibleActions` list
- Server validates using `RuleSet.validate(state, action)`
- Server applies using `RuleSet.reduce(state, action)`
  "phaseComplete": boolean
}
```

### 3. Action Submission Flow

Implement the action submission flow per A-013:

1. **Receive action**: Parse `POST /games/{gameId}/actions` request
2. **Deserialize**: Convert JSON to `GameAction` sealed class instance
3. **Authenticate**: Verify player is part of the game
4. **Validate**: Call `RuleSet.validate(state, action)`
   - Returns `ValidationResult.Valid` or `ValidationResult.Invalid(reason)`
5. **Reduce**: Call `RuleSet.reduce(state, action)` to get new state
6. **Chain automatic actions**: If new state has automatic actions, reduce those too
7. **Persist**: Save new `GameState` to database
8. **Respond**: Return new `GameState` with updated `possibleActions`
9. **Notify**: Emit state change event (if F-011 available)

### 4. Action Deserialization

Implement JSON to `GameAction` deserialization:
- Use Kotlin serialization with polymorphic discriminator
- Map `actionType` string to sealed class variant
- Deserialize `payload` into action-specific fields
- Handle unknown action types gracefully

Example:
```kotlin
@Serializable
@SerialName("AnnounceContract")
data class AnnounceContract(
  val playerId: PlayerId,
  val contract: ContractType
) : GameAction()
```

### 5. Display Name Generation

Generate user-friendly `displayName` for each action in `possibleActions`:
- "Good" for `AcceptContracts`
- "Double declarer's Game (2x → 4x)" for doubling with current/next multiplier
- "Announce Hundred" for defense contract announcements
- "Declare Open Hand" for open hand declarations
- "Accept" / "Play" for open hand responses

### 6. Error Handling

Per A-013, validation errors are returned by `RuleSet.validate()`. Map these to HTTP responses:

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "Cannot announce contract: not your turn",
    "details": {
      "currentPlayer": "player2",
      "attemptedBy": "player3"
    }
  }
}
```

Common validation failures:
- Not player's turn
- Invalid phase
- Duplicate defense contract
- Maximum doubling level reached
- Doubling order violation
- Action not in `possibleActions`

### 7. API Documentation

Update `docs/API.md` with:
- Explanation of Action Provider pattern for Contract Selection
- Example `possibleActions` for each player role (declarer, defense)
- Sample action submission requests for each contract action type
- Full contract selection flow example (announce → respond → double → transition)

Update OpenAPI specification:
- Document contract selection action types
- Add `ContractSelectionMetadata` schema
- Add `Commitment` and `OpenHandState` schemas
- Include examples for each action type

### 8. Testing

Create test cases in `docs/api-tests.http`:
- GET game state during CONTRACT_SELECTION phase
- POST declarer announces Game, Seven, Hundred, Hundred-Seven
- POST defense accepts
- POST defense doubles (all 4 levels)
- POST defense announces counter-contracts
- POST open hand declaration and responses
- Error cases: wrong player, invalid phase, duplicate contract, max doubling

## Acceptance Criteria

- [ ] Generic action endpoint handles all contract selection action types
- [ ] GameState response includes `possibleActions` from `RuleSet.possibleActions()`
- [ ] Action deserialization works for all contract action types
- [ ] Display names generated correctly for UI rendering
- [ ] Validation errors from `RuleSet.validate()` mapped to HTTP errors
- [ ] `RuleSet.reduce()` applied correctly, automatic actions chained
- [ ] State persistence after each action
- [ ] OpenAPI specification updated with contract schemas
- [ ] `docs/API.md` updated with contract selection examples
- [ ] `docs/api-tests.http` includes comprehensive test cases
- [ ] Real-time event emission works (if F-011 available)

## Definition of Done

- [ ] Unified `/games/{gameId}/actions` endpoint handles all contract action types
- [ ] Action deserialization works for: AnnounceContract, AcceptContracts, DoubleCommitment, AnnounceDefenseContract, DeclareOpenHand, RespondToOpenHand
- [ ] `GET /games/{gameId}` response includes `possibleActions` with contract actions
- [ ] GameState JSON response includes `ContractSelectionMetadata` correctly serialized
- [ ] Display names generated for each action (e.g., "Double declarer's Game (2x → 4x)")
- [ ] Action submission flow implemented: parse → auth → validate → reduce → persist → respond
- [ ] Validation errors from `RuleSet.validate()` mapped to HTTP error responses
- [ ] Automatic action chaining works (phase transitions executed within single request)
- [ ] OpenAPI specification updated with contract action schemas and metadata schemas
- [ ] `docs/API.md` updated with Contract Selection examples and flow documentation
- [ ] `docs/api-tests.http` includes test cases for all contract actions
- [ ] Error test cases included (wrong player, invalid phase, duplicate contract, max doubling)
- [ ] Integration tests verify complete contract selection flow via API
- [ ] Real-time event emission works if F-011 is available

## Related

- F-016: Contract Selection and Doubling
- R-006: Contract (Commitments)
- A-013: Rule-Based Engine and Action Provider
- T-051: RuleSet extension for contract selection
- T-052: Contract metadata in universal state model
- T-054: Web UI for contract selection (next)
- T-005: OpenAPI generation and docs (reference)
